<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: ElementosJogo.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: ElementosJogo.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/** 
 * @file Biblioteca de classes que representam vários tipos de &lt;em>gráficos&lt;/em> a desenhar num &lt;em>canvas&lt;/em>, bem como o próprio &lt;em>canvas&lt;/em>, &lt;em>audio&lt;/em> e &lt;em>video&lt;/em>, cujo propósito é facilitar o desenvolvimento de jogos e outras aplicações multimédia. Procura-se que esta biblioteca aborde apenas as situações mais comuns, evitando complexidade desnecessária.
 * @version 0.9
 * @author Ricardo Rodrigues
 * @date 2021-04-30
 * @copyright Ricardo Rodrigues (2021)
 */

/**
 * @class
 * @classdesc A classe &lt;code>Grafico&lt;/code> é, na prática, uma classe &lt;em>abstracta&lt;/em>, servindo apenas de base para as subclasses de &lt;code>Grafico&lt;/code>.
 * @property {number} x Abcissa para posicionar o &lt;em>gráfico&lt;/em> no canvas
 * @property {number} y Ordenada para posicionar o &lt;em>gráfico&lt;/em> no canvas
 * @property {number} deltaX=0 Variação horizontal da posição do &lt;em>gráfico&lt;/em>
 * @property {number} deltaY=0 Variação vertical da posição do &lt;em>gráfico&lt;/em>
 * @property {number} distX=0 Distância horizontal até um dado ponto &amp;mdash; pode ser usado, por exemplo, para guardar o &lt;em>offset&lt;/em> do &lt;em>x&lt;/em> até à posição &lt;em>x&lt;/em> do cursor do rato
 * @property {number} distY=0 Distância vertical até um dado ponto &amp;mdash; pode ser usado, por exemplo, para guardar o &lt;em>offset&lt;/em> do &lt;em>y&lt;/em> até à posição &lt;em>y&lt;/em> do cursor do rato
 * @property {number} angulo=0 Ângulo de rotação do &lt;em>gráfico&lt;/em> quando desenhado no &lt;em>canvas&lt;/em>
 * @property {boolean} activo=true Indicação de que o &lt;em>gráfico&lt;/em> deve testar colisões
 * @property {boolean} visivel=true - Indicação de que o &lt;em>gráfico&lt;/em> deve ser desenhado no &lt;em>canvas&lt;/em>
 * @property {boolean} seleccionado=false - Indicação de que o &lt;em>gráfico&lt;/em> se encontra seleccionado &amp;mdash; pode ser usado, por exemplo, para indicar que foi seleccionado com o cursor do rato
 */
class Grafico {
  /**
   * Construtor da classe &lt;code>Grafico&lt;/code>&lt;br>&lt;em>Este construtor não deve ser usado directamente. Se tal acontecer, é gerada uma excepção (&lt;code>TypeError&lt;/code>.)&lt;/em>
   * @param {number} x Abcissa para posicionar o &lt;em>gráfico&lt;/em> no &lt;em>canvas&lt;/em>
   * @param {number} y Ordenada para posicionar o &lt;em>gráfico&lt;/em> no &lt;em>canvas&lt;/em>
   */
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.deltaX = 0;
    this.deltaY = 0;
    this.distX = 0;
    this.distY = 0;
    this.angulo = 0;
    this.activo = true;
    this.visivel = true;
    this.seleccionado = false;
    if (this.constructor.name == "Grafico") {
      throw new TypeError("A classe abstracta 'Grafico' não pode ser instanciada directamente, devendo ser implementada através de subclasses (que poderão depois ser instanciadas).");
    }
  }

  /**
   * Este método encontra-se implementado na superclasse &lt;code>Grafico&lt;/code>, assumindo que todas as formas definidas nas suas subclasses são limitadas, de um modo genérico, por um rectângulo imaginário que engloba a totalidade do &lt;em>gráfico&lt;/em>. &lt;em>Se este método, tal como se encontra definido, não for o mais apropriado para uma dada subclasse, pode ser sempre redefinido (&lt;em>overrided&lt;/em>) nessa mesma subclasse.&lt;/em>
   * @param {Grafico} outro Outro &lt;em>gráfico&lt;/em> para verificar se existe alguma colisão entre esse e este
   * @returns {boolean} Se houver colisão, &lt;code>true&lt;/code>; se não, &lt;code>false&lt;/code>
   */
  colide(outro) {
    if (this.activo &amp;&amp; outro.activo &amp;&amp; (this.contemPonto(outro.x, outro.y) || this.contemPonto(outro.x + outro.largura, outro.y) || this.contemPonto(outro.x, outro.y + outro.altura) || this.contemPonto(outro.x + outro.largura, outro.y + outro.altura) || outro.contemPonto(this.x, this.y) || outro.contemPonto(this.x + this.largura, this.y) || outro.contemPonto(this.x, this.y + this.altura) || outro.contemPonto(this.x + this.largura, this.y + this.altura))) {
      return true;
    }
    else {
      return false;
    }
  }

  /**
   * &lt;em>Este método deve ser implementado nas subclasses de &lt;code>Grafico&lt;/code>, respeitando as especifidades de cada forma representada nelas. Se tal não acontecer, é gerada uma excepção (&lt;code>Error&lt;/code>.)&lt;/em>
   * @param {number} x Abcissa do ponto a testar se está contido
   * @param {number} y Ordenada do ponto a testar se está contido
   * @returns {boolean} Se o ponto estiver contido neste &lt;em>grafico&lt;/em>, &lt;code>true&lt;/code>; se não, &lt;code>false&lt;/code>
   */
  contemPonto(x, y) {
    throw new Error("O método 'contemPonto(x, y)' tem de ser implementado nas subclasses da classe 'Grafico'.");
  }

  /**
   * Este método mais não faz que chamar o método &lt;code>contemPonto(x, y)&lt;/code> para cada um dos pontos do &lt;em>array&lt;/em>.
   * @param {Array} pontos
   * @returns {boolean} Se qualquer um dos pontos constantes no &lt;em>array&lt;/em> estiver contido neste &lt;em>grafico&lt;/em>, &lt;code>true&lt;/code>; se não, &lt;code>false&lt;/code>
   */
  contemPontos(pontos) {
    for (var i = 0; i &lt; pontos.length; i++) {
      if (this.contemPonto(pontos[i].x, pontos[i].y)) {
        return true;
      }
    }
    return false;
  }

  /**
   * &lt;em>Este método deve ser implementado nas subclasses de &lt;code>Grafico&lt;/code>, respeitando as especifidades de cada forma representada nelas. Se tal não acontecer, é gerada uma excepção (&lt;code>Error&lt;/code>.)&lt;/em>
   * @param {Tela} tela Objecto que representa o elemento &lt;em>canvas&lt;/em> onde será desenhado o &lt;em>gráfico&lt;/em>
   */
  desenha(tela) {
    throw new Error("O método 'desenha(tela)' tem de ser implementado nas subclasses da classe 'Grafico'.");
  }
}

//

/**
 * @class
 * @extends Grafico
 * @classdesc A classe &lt;code>Circulo&lt;/code> é uma subclasse de &lt;code>Grafico&lt;/code>, servindo para representar círculos.
 */
class Circulo extends Grafico {
  /**
   * DESCRIÇÃO...
   * @param {any} x
   * @param {any} y
   * @param {any} raio
   * @param {any} preenchimento="black"
   * @param {any} contorno="black"
   * @param {any} espessura=0
   */
  constructor(x, y, raio, preenchimento = "black", contorno = "black", espessura = 0) {
    super(x, y);
    this.raio = raio;
    // ATENÇÃO: se o valor do preenchimento for definido como "empty", a forma não é preenchida
    this.preenchimento = preenchimento;
    this.contorno = contorno;
    // ATENÇÃO: se o contorno tiver uma espessura de 0(px), não é desenhado
    this.espessura = espessura;
  }

  /**
   * DESCRIÇÃO...
   * @returns {number}
   */
  get largura() {
    return this.raio * 2;
  }

  /**
   * DESCRIÇÃO...
   * @returns {number}
   */
  get altura() {
    return this.raio * 2;
  }

  // ATENÇÃO: para que exista uniformidade no posicionamento das formas representadas pelas várias subclasses, os círculos são também posicionados usando o canto superior esquerdo (de um rectângulo imaginário que o contenha), em vez do seu centro -- daí, o raio é somado ao x e ao y para fazer as devidas compensações de posicionamento
  /**
   * DESCRIÇÃO...
   * @param {number} x
   * @param {number} y
   * @returns {boolean}
   */
  contemPonto(x, y) {
    if (Math.hypot((this.x + this.raio) - x, (this.y + this.raio) - y) &lt; this.raio) {
      return true;
    } else {
      return false;
    }
  }

  // ATENÇÃO: para que exista uniformidade no posicionamento das formas representadas pelas várias subclasses, os círculos são também posicionados usando o canto superior esquerdo (de um rectângulo imaginário que o contenha), em vez do seu centro -- daí, o raio é somado ao x e ao y para fazer as devidas compensações de posicionamento
  /**
   * DESCRIÇÃO...
   * @param {Tela} tela
   */
  desenha(tela) {
    if (this.visivel) {
      // ATENÇÃO: no caso de um círculo, definir um ângulo de rotação é irrelevante, pelo não se implementa, até para evitar processamento desnecessário
      var contexto = tela.contexto;
      contexto.save();
      contexto.beginPath();
      contexto.arc(Math.floor(this.x + this.raio), Math.floor(this.y + this.raio), this.raio, 0, Math.PI * 2);
      contexto.closePath();
      contexto.fillStyle = this.preenchimento;
      contexto.strokeStyle = this.contorno;
      contexto.lineWidth = this.espessura;
      if (this.preenchimento.toLowerCase() != "empty") {
        contexto.fill();
      }
      if ((this.contorno.toLowerCase() != "empty") &amp;&amp; (this.espessura > 0)) {
        contexto.stroke();
      }
      contexto.restore();
    }
    this.x += this.deltaX;
    this.y += this.deltaY;
  }
}

//

// CLASSE: Rectangulo
class Rectangulo extends Grafico {
  /**
   * DESCRIÇÃO...
   * @param {any} x
   * @param {any} y
   * @param {any} largura
   * @param {any} altura
   * @param {any} preenchimento="black"
   * @param {any} contorno="black"
   * @param {any} espessura=0
   * @returns {any}
   */
  constructor(x, y, largura, altura, preenchimento = "black", contorno = "black", espessura = 0) {
    super(x, y);
    this.largura = largura;
    this.altura = altura;
    // ATENÇÃO: se o valor do preenchimento for definido como "empty", a forma não é preenchida
    this.preenchimento = preenchimento;
    this.contorno = contorno;
    // ATENÇÃO: se o contorno tiver uma espessura de 0(px), não é desenhado
    this.espessura = espessura;
  }

  /**
   * DESCRIÇÃO...
   * @param {any} x
   * @param {any} y
   * @returns {any}
   */
  contemPonto(x, y) {
    if ((this.x &lt;= x) &amp;&amp; (this.x + this.largura >= x) &amp;&amp; (this.y &lt;= y) &amp;&amp; (this.y + this.altura >= y)) {
      return true;
    }
    else {
      return false;
    }
  }

  /**
   * DESCRIÇÃO...
   * @param {any} tela
   * @returns {any}
   */
  desenha(tela) {
    if (this.visivel) {
      var contexto = tela.contexto;
      contexto.save();
      contexto.beginPath();
      // ATENÇÃO: para evitar processamento desnecessário, só se faz a translação e a rotação quando o angulo é diferente de zero (0), já que, quando o ângulo tem esse valor, o resultado é idêntico a quando não se faz qualquer rotação
      if (this.angulo != 0) {
        contexto.translate(Math.floor(this.x + this.largura * 0.5), Math.floor(this.y + this.altura * 0.5));
        contexto.rotate(this.angulo * Math.PI / 180);
        contexto.rect(Math.floor(-this.largura * 0.5), Math.floor(-this.altura * 0.5), this.largura, this.altura);
      }
      else {
        contexto.rect(Math.floor(this.x), Math.floor(this.y), this.largura, this.altura);
      }
      contexto.closePath();
      contexto.fillStyle = this.preenchimento;
      contexto.strokeStyle = this.contorno;
      contexto.lineWidth = this.espessura;
      if (this.preenchimento.toLowerCase() != "empty") {
        contexto.fill();
      }
      if ((this.contorno.toLowerCase() != "empty") &amp;&amp; (this.espessura > 0)) {
        contexto.stroke();
      }
      contexto.restore();
    }
    this.x += this.deltaX;
    this.y += this.deltaY;
  }
}

//

// CLASSE: Poligono
class Poligono extends Grafico {
  /**
   * DESCRIÇÃO...
   * @param {any} x
   * @param {any} y
   * @param {any} pontos
   * @param {any} preenchimento="black"
   * @param {any} contorno="black"
   * @param {any} espessura=0
   * @param {any} ajuste=true
   * @returns {any}
   */
  constructor(x, y, pontos, preenchimento = "black", contorno = "black", espessura = 0, ajuste = true) {
    // ATENÇÃO: as coordenadas (x, y) correspondem ao canto superior esquerdo de um rectângulo imaginário que conterá o polígono (a origem) e, assim, será o ponto relativamente ao qual todos os pontos do polígono serão posicionados; aconselha-se que todos os pontos do polígono se encontrem à direita e abaixo desta origem e tão próximos dela quanto possível; caso contrário, aspectos como a rotação do polígono poderão ter resultados diferentes do esperado, o mesmo acontecendo com as colisões baseadas nesse rectângulo imaginário; há a possibilidade, activada por omissão através do atributo ajuste, de "encostar" o polígono à origem -- contudo, tal implica uma alteração (ajuste) de todos os pontos
    super(x, y);
    this.pontos = pontos;
    // ATENÇÃO: se o valor do preenchimento for definido como "empty", a forma não é preenchida
    this.preenchimento = preenchimento;
    this.contorno = contorno;
    // ATENÇÃO: se o contorno tiver uma espessura de 0(px), não é desenhado
    this.espessura = espessura;
    // ATENÇÃO: se ajuste for verdadeiro (true), todo os pontos são alterados de forma a que o polígono seja "encostado" à origem -- o ponto (x, y) do polígono; se for necessário recuperar os pontos originais, tal pode ser feito com auxílio dos atributos deslocX e deslocY; se ajuste for verdadeiro, desaconselha-se a alteração do atributo pontos depois de criada a instância da classe
    this.ajuste = ajuste;
    this.deslocX = 0;
    this.deslocY = 0;
    if (this.ajuste) {
      this.deslocX = Number.MAX_VALUE;
      for (var i = 0, j = this.pontos.length - 1; i &lt; this.pontos.length; j = i++) {
        this.deslocX = Math.min(this.deslocX, this.pontos[i].x);
      }
      this.deslocY = Number.MAX_VALUE;
      for (var i = 0, j = this.pontos.length - 1; i &lt; this.pontos.length; j = i++) {
        this.deslocY = Math.min(this.deslocY, this.pontos[i].y);
      }
      for (var i = 0; i &lt; this.pontos.length; i++) {
        pontos[i].x -= this.deslocX;
        pontos[i].y -= this.deslocY;
      }
    }
  }

  /**
   * DESCRIÇÃO...
   * @returns {any}
   */
  get largura() {
    var minX = Number.MAX_VALUE;
    var maxX = Number.MIN_VALUE;
    for (var i = 0, j = this.pontos.length - 1; i &lt; this.pontos.length; j = i++) {
      minX = Math.min(minX, this.pontos[i].x);
      maxX = Math.max(maxX, this.pontos[j].x);
    }
    return maxX - minX;
  }

  /**
   * DESCRIÇÃO...
   * @returns {any}
   */
  get altura() {
    var minY = Number.MAX_VALUE;
    var maxY = Number.MIN_VALUE;
    for (var i = 0, j = this.pontos.length - 1; i &lt; this.pontos.length; j = i++) {
      minY = Math.min(minY, this.pontos[i].y);
      maxY = Math.max(maxY, this.pontos[j].y);
    }
    return maxY - minY;
  }

  /**
   * DESCRIÇÃO...
   * @param {any} x
   * @param {any} y
   * @returns {any}
   */
  contemPonto(x, y) {
    var contido = false;
    for (var i = 0, j = this.pontos.length - 1; i &lt; this.pontos.length; j = i++) {
      var pontoI = { x: this.pontos[i].x + this.x, y: this.pontos[i].y + this.y };
      var pontoJ = { x: this.pontos[j].x + this.x, y: this.pontos[j].y + this.y };
      if (((pontoI.y > y) != (pontoJ.y > y)) &amp;&amp; (x &lt; (pontoJ.x - pontoI.x) * (y - pontoI.y) / (pontoJ.y - pontoI.y) + pontoI.x)) {
        contido = !contido;
      }
    }
    return contido;
  }

  /**
   * DESCRIÇÃO...
   * @param {any} tela
   * @returns {any}
   */
  desenha(tela) {
    if (this.visivel) {
      var contexto = tela.contexto;
      contexto.save();
      contexto.beginPath()
      // ATENÇÃO: para evitar processamento desnecessário, só se faz a translação e a rotação quando o angulo é diferente de zero (0), já que, quando o ângulo tem esse valor, o resultado é idêntico a quando não se faz qualquer rotação
      if (this.angulo != 0) {
        contexto.translate(Math.floor(this.x + this.largura * 0.5), Math.floor(this.y + this.altura * 0.5));
        contexto.rotate(this.angulo * Math.PI / 180);
        for (var i = 0; i &lt; this.pontos.length; i++) {
          if (i == 0) {
            contexto.moveTo(Math.floor(this.pontos[i].x - this.largura * 0.5), Math.floor(this.pontos[i].y - this.altura * 0.5));
          }
          else {
            contexto.lineTo(Math.floor(this.pontos[i].x - this.largura * 0.5), Math.floor(this.pontos[i].y - this.altura * 0.5));
          }
        }
      }
      else {
        for (var i = 0; i &lt; this.pontos.length; i++) {
          if (i == 0) {
            contexto.moveTo(Math.floor(this.pontos[i].x + this.x), Math.floor(this.pontos[i].y + this.y));
          }
          else {
            contexto.lineTo(Math.floor(this.pontos[i].x + this.x), Math.floor(this.pontos[i].y + this.y));
          }
        }
      }
      contexto.closePath();
      contexto.fillStyle = this.preenchimento;
      contexto.strokeStyle = this.contorno;
      contexto.lineWidth = this.espessura;
      if (this.preenchimento.toLowerCase() != "empty") {
        contexto.fill();
      }
      if ((this.contorno.toLowerCase() != "empty") &amp;&amp; (this.espessura > 0)) {
        contexto.stroke();
      }
      contexto.restore();
    }
    this.x += this.deltaX;
    this.y += this.deltaY;
  }
}

//

// CLASSE: Texto
class Texto extends Grafico {
  /**
   * DESCRIÇÃO...
   * @param {any} x
   * @param {any} y
   * @param {any} texto
   * @param {any} preenchimento="black"
   * @param {any} contorno="black"
   * @param {any} espessura=0
   * @returns {any}
   */
  constructor(x, y, texto, preenchimento = "black", contorno = "black", espessura = 0) {
    super(x, y);
    this.texto = texto;
    // ATENÇÃO: se o valor do preenchimento for definido como "empty", a forma não é preenchida
    this.preenchimento = preenchimento;
    this.contorno = contorno;
    // ATENÇÃO: se o contorno tiver uma espessura de 0(px), não é desenhado
    this.espessura = espessura;
    // ATENÇÃO: por omissão, o tamanho do texto (fonte) é de 16(px)
    this.tamanho = 16;
    // ATENÇÃO: por omissão, a fonte é sem serifas -- a que o sistema tiver predefinida
    this.fonte = "sans-serif";
    // ATENÇÃO: por omissão, o alinhamento é feito à esquerda
    this.alinhamento = "left";
    // ATENÇÃO: por omissão, a base é feita ao topo do texto
    this.base = "top";
  }

  /**
   * DESCRIÇÃO...
   * @returns {any}
   */
  get largura() {
    var tela = document.createElement("canvas");
    var contexto = tela.getContext("2d");
    contexto.font = this.altura + "px " + this.fonte;
    return Math.floor(contexto.measureText(this.texto).width);
  }

  /**
   * DESCRIÇÃO...
   * @returns {any}
   */
  get altura() {
    return this.tamanho;
  }

  /**
   * DESCRIÇÃO...
   * @param {any} x
   * @param {any} y
   * @returns {any}
   */
  contemPonto(x, y) {
    if ((this.x &lt;= x) &amp;&amp; (this.x + this.largura >= x) &amp;&amp; (this.y &lt;= y) &amp;&amp; (this.y + this.altura >= y)) {
      return true;
    }
    else {
      return false;
    }
  }

  /**
   * DESCRIÇÃO...
   * @param {any} tela
   * @returns {any}
   */
  desenha(tela) {
    if (this.visivel) {
      var contexto = tela.contexto;
      contexto.save();
      contexto.fillStyle = this.preenchimento;
      contexto.strokeStyle = this.contorno;
      contexto.textAlign = this.alinhamento;
      contexto.textBaseline = this.base;
      contexto.font = this.tamanho + "px " + this.fonte;
      contexto.fillStyle = this.preenchimento;
      // ATENÇÃO: para evitar processamento desnecessário, só se faz a translação e a rotação quando o angulo é diferente de zero (0), já que, quando o ângulo tem esse valor, o resultado é idêntico a quando não se faz qualquer rotação
      if (this.angulo != 0) {
        contexto.translate(Math.floor(this.x + this.largura * 0.5), Math.floor(this.y + this.altura * 0.5));
        contexto.rotate(this.angulo * Math.PI / 180);
        if (this.preenchimento.toLowerCase() != "empty") {
          contexto.fillText(this.texto, Math.floor(-this.largura * 0.5), Math.floor(-this.altura * 0.5));
        }
        if ((this.contorno.toLowerCase() != "empty") &amp;&amp; (this.espessura > 0)) {
          contexto.strokeText(this.texto, Math.floor(-this.largura * 0.5), Math.floor(-this.altura * 0.5));
        }
      }
      else {
        if (this.preenchimento.toLowerCase() != "empty") {
          contexto.fillText(this.texto, Math.floor(this.x), Math.floor(this.y));
        }
        if ((this.contorno.toLowerCase() != "empty") &amp;&amp; (this.espessura > 0)) {
          contexto.strokeText(this.texto, Math.floor(this.x), Math.floor(this.y));
        }
      }
      contexto.restore();
    }
    this.x += this.deltaX;
    this.y += this.deltaY;
  }
}

//

// CLASSE: Imagem
class Imagem extends Grafico {
  /**
   * DESCRIÇÃO...
   * @param {any} x
   * @param {any} y
   * @param {any} imagem
   * @returns {any}
   */
  constructor(x, y, imagem) {
    super(x, y);
    this.imagem = imagem;
  }

  /**
   * DESCRIÇÃO...
   * @returns {any}
   */
  get largura() {
    return this.imagem.width;
  }

  /**
   * DESCRIÇÃO...
   * @returns {any}
   */
  get altura() {
    return this.imagem.height;
  }

  contemPonto(x, y) {
    if ((this.x &lt;= x) &amp;&amp; (this.x + this.largura >= x) &amp;&amp; (this.y &lt;= y) &amp;&amp; (this.y + this.altura >= y)) {
      return true;
    }
    else {
      return false;
    }
  }

  /**
   * DESCRIÇÃO...
   * @param {any} tela
   * @returns {any}
   */
  desenha(tela) {
    if (this.visivel) {
      var contexto = tela.contexto;
      // ATENÇÃO: para evitar processamento desnecessário, só se faz a translação e a rotação quando o angulo é diferente de zero (0), já que, quando o ângulo tem esse valor, o resultado é idêntico a quando não se faz qualquer rotação
      if (this.angulo != 0) {
        contexto.save();
        contexto.translate(Math.floor(this.x + this.largura * 0.5), Math.floor(this.y + this.altura * 0.5));
        contexto.rotate(this.angulo * Math.PI / 180);
        contexto.drawImage(this.imagem, Math.floor(-this.largura * 0.5), Math.floor(-this.altura * 0.5));
        contexto.restore();
      }
      else {
        contexto.drawImage(this.imagem, Math.floor(this.x), Math.floor(this.y));
      }
    }
    this.x += this.deltaX;
    this.y += this.deltaY;
  }
}

//

// CLASSE: ImagemAnimada (apenas para "sprites" com uma sequência horizontal e com fotogramas de dimensões idênticas)
class ImagemAnimada extends Imagem {
  /**
   * DESCRIÇÃO...
   * @param {any} x
   * @param {any} y
   * @param {any} imagem
   * @param {any} fotogramas
   * @param {any} iteracoes
   * @returns {any}
   */
  constructor(x, y, imagem, fotogramas, iteracoes) {
    super(x, y, imagem);
    this.fotogramas = fotogramas;
    this.iteracoes = iteracoes;
    this.animada = true;
    this.indice = 0;
  }

  /**
   * DESCRIÇÃO...
   * @returns {any}
   */
  get largura() {
    return this.imagem.width / this.fotogramas;
  }

  /**
   * DESCRIÇÃO...
   * @param {any} tela
   * @returns {any}
   */
  desenha(tela) {
    if (this.visivel) {
      var contexto = tela.contexto;
      // ATENÇÃO: para evitar processamento desnecessário, só se faz a translação e a rotação quando o angulo é diferente de zero (0), já que, quando o ângulo tem esse valor, o resultado é idêntico a quando não se faz qualquer rotação
      if (this.angulo != 0) {
        contexto.save();
        contexto.translate(Math.floor(this.x + this.largura * 0.5), Math.floor(this.y + this.altura * 0.5));
        contexto.rotate(this.angulo * Math.PI / 180);
        contexto.drawImage(this.imagem, this.indice * this.largura, 0, this.largura, this.altura, Math.floor(-this.largura * 0.5), Math.floor(-this.altura * 0.5), this.largura, this.altura);
        contexto.restore();
      }
      else {
        contexto.drawImage(this.imagem, this.indice * this.largura, 0, this.largura, this.altura, Math.floor(this.x), Math.floor(this.y), this.largura, this.altura);
      }
      if ((this.animada) || (this.indice > 0)) {
        if (this.contador % this.iteracoes == 0) {
          this.indice++;
          if (indice >= this.fotogramas) {
            indice = 0;
          }
        }
        this.indice = this.apontador % this.fotogramas;
        this.contador++;
      }
    }
    this.x += this.deltaX;
    this.y += this.deltaY;
  }
}

//

/**
 * Esta função desenha um &lt;em>gráfico&lt;/em> ou percorre um &lt;em>array&lt;/em> de &lt;em>gráficos&lt;/em> (instâncias ou objectos de subclasses da classe &lt;code>Grafico&lt;/code> e desenha-os no &lt;em>canvas&lt;/em> especificado. O &lt;em>array&lt;/em> pode conter também &lt;em>arrays&lt;/em> em qualquer das suas posições, já que esta função é recursiva.
 * @param {Grafico} graficos Um &lt;em>gráfico&lt;/em> ou um &lt;em>array&lt;/em> de &lt;em>gráficos&lt;/em>
 * @param {Tela} tela O &lt;em>canvas&lt;/em> onde vão ser desenhados os &lt;em>gráficos&lt;/em>
 */
function desenhaGraficos(graficos, tela) {
  for (var i = 0; i &lt; graficos.length; i++) {
    if (Array.isArray(graficos[i])) {
      desenhaGraficos(graficos[i], tela);
    } else {
      graficos[i].desenha(tela);
    }
  }
}

//

// CLASSE: Tela
class Tela {
  /**
   * DESCRIÇÃO...
   * @param {any} tela
   * @returns {any}
   */
  constructor(tela) {
    this.tela = tela;
  }

  // ATENÇÃO: este método (getter) devolve o elemento original usado na criação de uma instância da classe Tela, para que possa ser manipulado directamente -- por exemplo, quando é necessário adicionar eventos ao elemento
  /**
   * DESCRIÇÃO...
   * @returns {any}
   */
  get elemento() {
    return this.tela;
  }

  /**
   * DESCRIÇÃO...
   * @returns {any}
   */
  get contexto() {
    return this.tela.getContext("2d");
  }

  /**
   * DESCRIÇÃO...
   * @returns {any}
   */
  get largura() {
    return this.tela.width;
  }

  /**
   * DESCRIÇÃO...
   * @returns {any}
   */
  get altura() {
    return this.tela.height;
  }

  // ATENÇÃO: este método (getter) devolve a largura do elemento na página web, incluindo quaisquer alterações decorrentes da utilização de CSS
  /**
   * DESCRIÇÃO...
   * @returns {any}
   */
  get larguraFinal() {
    return this.tela.offsetWidth;
  }

  // ATENÇÃO: este método (getter) devolve a altura do elemento na página web, incluindo quaisquer alterações decorrentes da utilização de CSS
  /**
   * DESCRIÇÃO...
   * @returns {any}
   */
  get alturaFinal() {
    return this.tela.offsetHeight;
  }
}

//

// CLASSE: Som
class Som {
  /**
   * DESCRIÇÃO...
   * @param {any} som
   * @returns {any}
   */
  constructor(som) {
    this.som = som;
  }

  // ATENÇÃO: este método (getter) devolve o elemento original usado na criação de uma instância da classe Tela, para que possa ser manipulado directamente -- por exemplo, quando é necessário adicionar eventos ao elemento
  /**
   * DESCRIÇÃO...
   * @returns {any}
   */
  get elemento() {
    return this.som;
  }

  /**
   * DESCRIÇÃO...
   * @param {any} fonte
   * @returns {any}
   */
  set fonte(fonte) {
    this.som.src = fonte;
  }

  /**
   * DESCRIÇÃO...
   * @returns {any}
   */
  get fonte() {
    return this.som.src;
  }

  /**
   * DESCRIÇÃO...
   * @returns {any}
   */
  get duracao() {
    return this.som.duration;
  }

  /**
   * DESCRIÇÃO...
   * @param {any} volume
   * @returns {any}
   */
  set volume(volume) {
    this.som.volume = volume;
  }

  /**
   * DESCRIÇÃO...
   * @returns {any}
   */
  get volume() {
    return this.som.volume;
  }

  /**
   * DESCRIÇÃO...
   * @param {any} tempo
   * @returns {any}
   */
  set indicador(tempo) {
    this.filme.currentTime = tempo;
  }

  /**
   * DESCRIÇÃO...
   * @returns {any}
   */
  get indicador() {
    return this.filme.currentTime;
  }

  /**
   * DESCRIÇÃO...
   * @returns {any}
   */
  reproduz() {
    this.som.play();
  }

  /**
   * DESCRIÇÃO...
   * @returns {any}
   */
  pausa() {
    this.som.pause();
  }

  /**
   * DESCRIÇÃO...
   * @returns {any}
   */
  para() {
    this.pausa();
    this.som.currentTime = 0;
  }
}

//

// CLASSE: Filme
class Filme {
  /**
   * DESCRIÇÃO...
   * @param {any} filme
   * @returns {any}
   */
  constructor(filme) {
    this.filme = filme;
  }

  // ATENÇÃO: este método (getter) devolve o elemento original usado na criação de uma instância da classe Tela, para que possa ser manipulado directamente -- por exemplo, quando é necessário adicionar eventos ao elemento
  /**
   * DESCRIÇÃO...
   * @returns {any}
   */
  get elemento() {
    return this.filme;
  }

  /**
   * DESCRIÇÃO...
   * @param {any} fonte
   * @returns {any}
   */
  set fonte(fonte) {
    this.filme.src = fonte;
  }

  /**
   * DESCRIÇÃO...
   * @returns {any}
   */
  get fonte() {
    return this.filme.src;
  }

  /**
   * DESCRIÇÃO...
   * @returns {any}
   */
  get duracao() {
    return this.filme.duration;
  }

  /**
   * DESCRIÇÃO...
   * @returns {any}
   */
  get largura() {
    return this.filme.videoWidth;
  }

  /**
   * DESCRIÇÃO...
   * @returns {any}
   */
  get altura() {
    return this.filme.videoHeight;
  }

  // ATENÇÃO: este método (getter) devolve a largura do elemento na página web, incluindo quaisquer alterações decorrentes da utilização de CSS
  /**
   * DESCRIÇÃO...
   * @returns {any}
   */
  get larguraFinal() {
    return this.filme.offsetWidth;
  }

  // ATENÇÃO: este método (getter) devolve a altura do elemento na página web, incluindo quaisquer alterações decorrentes da utilização de CSS
  /**
   * DESCRIÇÃO...
   * @returns {any}
   */
  get alturaFinal() {
    return this.filme.offsetHeight;
  }

  /**
   * DESCRIÇÃO...
   * @param {any} volume
   * @returns {any}
   */
  set volume(volume) {
    this.filme.volume = volume;
  }

  /**
   * DESCRIÇÃO...
   * @returns {any}
   */
  get volume() {
    return this.filme.volume;
  }

  /**
   * DESCRIÇÃO...
   * @param {any} tempo
   * @returns {any}
   */
  set indicador(tempo) {
    this.filme.currentTime = tempo;
  }

  /**
   * DESCRIÇÃO...
   * @returns {any}
   */
  get indicador() {
    return this.filme.currentTime;
  }

  /**
   * DESCRIÇÃO...
   * @returns {any}
   */
  reproduz() {
    this.filme.play();
  }

  /**
   * DESCRIÇÃO...
   * @returns {any}
   */
  pausa() {
    this.filme.pause();
  }

  /**
   * DESCRIÇÃO...
   * @returns {any}
   */
  para() {
    this.pausa();
    this.filme.currentTime = 0;
  }
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Circulo.html">Circulo</a></li><li><a href="Filme.html">Filme</a></li><li><a href="Grafico.html">Grafico</a></li><li><a href="Imagem.html">Imagem</a></li><li><a href="ImagemAnimada.html">ImagemAnimada</a></li><li><a href="Poligono.html">Poligono</a></li><li><a href="Rectangulo.html">Rectangulo</a></li><li><a href="Som.html">Som</a></li><li><a href="Tela.html">Tela</a></li><li><a href="Texto.html">Texto</a></li></ul><h3>Global</h3><ul><li><a href="global.html#desenhaGraficos">desenhaGraficos</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.6</a> on Wed Apr 28 2021 12:36:07 GMT+0100 (Western European Summer Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
